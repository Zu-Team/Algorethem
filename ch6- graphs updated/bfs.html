<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFS - Graph Algorithms</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .queue-display {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            padding: 12px;
            border-radius: 8px;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .queue-item {
            width: 40px;
            height: 40px;
            background: rgba(33, 150, 243, 0.15);
            border: 2px solid var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--text-main);
            transition: all 0.3s;
        }
        .queue-item:first-child {
            background: rgba(255, 234, 0, 0.15);
            border-color: var(--warning);
        }
        .queue-label {
            margin-right: 10px;
            font-weight: bold;
            color: var(--accent);
            font-size: 0.85rem;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <header>
        <div class="breadcrumb">
            <a href="../index.html">Home</a> &gt; <a href="index.html">Chapter 6</a> &gt; <span>BFS</span>
        </div>
        <div class="page-title">Breadth-First Search</div>
        <div></div>
    </header>

    <div class="main-grid">
        <div class="control-panel">
            <div class="panel-section">
                <h3>Problem</h3>
                <p class="status-text" style="font-size: 0.9rem; min-height: auto;">
                    Traverse the graph starting from a source vertex <strong>s</strong> level by level.
                    <br><br>
                    <strong>Strategy:</strong> Use a FIFO Queue. Visit neighbors, mark as Gray (Discovered), then Black (Finished).
                </p>
            </div>

            <div class="panel-section">
                <h3>Controls</h3>
                <div class="controls">
                    <button id="btnPrev">‚èÆ</button>
                    <button id="btnPlay" class="primary-btn">‚ñ∂ Play</button>
                    <button id="btnNext">‚è≠</button>
                    <button id="btnReset">‚Üª</button>
                    <button id="btnRandom" title="New Random Graph">üé≤</button>
                    <button id="btnSpanTree" title="Generate Spanning Tree">üå≥</button>
                    <button id="btnExample" title="Load Slide Example">üìñ</button>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; margin-top:10px; font-size:0.85rem; color:var(--text-mute);">
                    <span>Start:</span>
                    <select id="startSelect" style="background:#2a2a2a; border:1px solid #444; color:var(--text-main); padding:6px 8px; border-radius:6px; font-size:0.85rem;"></select>
                </div>
                <div style="display:flex; gap:10px; align-items:center; justify-content:center; margin-top:10px; font-size:0.85rem; color:var(--text-mute);">
                    <span>Graph:</span>
                    <label style="display:flex; gap:6px; align-items:center; cursor:pointer;">
                        <input type="radio" name="graphMode" id="modeDirected" value="directed">
                        <span>Directed</span>
                    </label>
                    <label style="display:flex; gap:6px; align-items:center; cursor:pointer;">
                        <input type="radio" name="graphMode" id="modeUndirected" value="undirected" checked>
                        <span>Undirected</span>
                    </label>
                </div>
                <div class="speed-control">
                    <span>Slow</span>
                    <input type="range" id="speedRange" min="100" max="1900" value="1000">
                    <span>Fast</span>
                </div>
            </div>

            <div class="panel-section">
                <h3>Current Step</h3>
                <div id="step-counter" style="margin-bottom: 5px; font-weight: bold; color: var(--accent);">0 / 0</div>
                <p id="step-desc" class="status-text">Ready...</p>
            </div>

            <div class="panel-section">
                <h3>Results (color / d / p)</h3>
                <div id="results-table" style="font-family: var(--font-mono); font-size: 0.8rem;"></div>
            </div>
        </div>

        <div class="viz-panel">
            <div id="canvas-container">
                <!-- SVG Here -->
                <div class="queue-display">
                    <span class="queue-label">QUEUE:</span>
                    <div id="queue-visuals" style="display:flex; gap:5px;"></div>
                </div>
            </div>
            
            <div class="pseudocode-container">
                <div class="code-line" id="line-1"><strong>BFS(G, s):</strong></div>
                <div class="code-line" id="line-2">1&nbsp;&nbsp;for each u in V(G) \\ {s}</div>
                <div class="code-line" id="line-3">2&nbsp;&nbsp;&nbsp;&nbsp;color[u] = WHITE</div>
                <div class="code-line" id="line-4">3&nbsp;&nbsp;&nbsp;&nbsp;d[u] = ‚àû</div>
                <div class="code-line" id="line-5">4&nbsp;&nbsp;&nbsp;&nbsp;p[u] = NIL</div>
                <div class="code-line" id="line-6">5&nbsp;&nbsp;color[s] = GRAY</div>
                <div class="code-line" id="line-7">6&nbsp;&nbsp;d[s] = 0</div>
                <div class="code-line" id="line-8">7&nbsp;&nbsp;p[s] = NIL</div>
                <div class="code-line" id="line-9">8&nbsp;&nbsp;Q = ‚àÖ</div>
                <div class="code-line" id="line-10">9&nbsp;&nbsp;ENQUEUE(Q, s)</div>
                <div class="code-line" id="line-11">10&nbsp;while Q ‚â† ‚àÖ</div>
                <div class="code-line" id="line-12">11&nbsp;&nbsp;u = DEQUEUE(Q)</div>
                <div class="code-line" id="line-13">12&nbsp;&nbsp;for each v in Adj[u]</div>
                <div class="code-line" id="line-14">13&nbsp;&nbsp;&nbsp;&nbsp;if color[v] == WHITE</div>
                <div class="code-line" id="line-15">14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color[v] = GRAY</div>
                <div class="code-line" id="line-16">15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[v] = d[u] + 1</div>
                <div class="code-line" id="line-17">16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[v] = u</div>
                <div class="code-line" id="line-18">17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENQUEUE(Q, v)</div>
                <div class="code-line" id="line-19">18&nbsp;&nbsp;color[u] = BLACK</div>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
    <script>
        // Slide Example (CLRS-style): vertices r,s,t,u,v,w,x,y starting at s (undirected)
        const SLIDE_EXAMPLE = {
            mode: 'undirected',
            start: 's',
            nodes: [
                { id: 'r', x: 250, y: 50 },
                { id: 's', x: 100, y: 100 },
                { id: 't', x: 400, y: 100 },
                { id: 'u', x: 450, y: 200 },
                { id: 'v', x: 250, y: 200 },
                { id: 'w', x: 100, y: 250 },
                { id: 'x', x: 350, y: 300 },
                { id: 'y', x: 450, y: 350 }
            ],
            // Edge insertion order defines Adj[u] order (DO NOT SORT)
            edges: [
                { src: 'r', dest: 's' },
                { src: 's', dest: 'w' },
                { src: 'r', dest: 'v' },
                { src: 'w', dest: 't' },
                { src: 'w', dest: 'x' },
                { src: 't', dest: 'x' },
                { src: 't', dest: 'u' },
                { src: 'x', dest: 'u' },
                { src: 'x', dest: 'y' },
                { src: 'u', dest: 'y' }
            ]
        };

        let GRAPH_MODE = SLIDE_EXAMPLE.mode; // 'directed' | 'undirected'
        let START = SLIDE_EXAMPLE.start;

        let NODES = JSON.parse(JSON.stringify(SLIDE_EXAMPLE.nodes));
        let EDGES = JSON.parse(JSON.stringify(SLIDE_EXAMPLE.edges));

        // Build adjacency list once (preserve insertion order, DO NOT sort)
        function buildAdjacency(nodes, edges, mode) {
            const adj = new Map();
            nodes.forEach(n => adj.set(n.id, []));

            edges.forEach(e => {
                if (adj.has(e.src)) adj.get(e.src).push(e.dest);
                if (mode === 'undirected') {
                    if (adj.has(e.dest)) adj.get(e.dest).push(e.src);
                }
            });
            return adj;
        }

        function getNeighborsFromAdj(adj, uId) {
            return adj.get(uId) ? [...adj.get(uId)] : [];
        }

        // Random Graph Generator (keeps adjacency insertion order deterministic)
        function generateRandomGraph() {
            const numNodes = Math.floor(Math.random() * 3) + 6; // 6 to 8 nodes
            const newNodes = [];
            const newEdges = [];
            const width = 600;
            const height = 350;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;

            // Organized circular layout (like Chapter 5)
            for (let i = 0; i < numNodes; i++) {
                const angle = (2 * Math.PI * i) / numNodes;
                newNodes.push({
                    id: String.fromCharCode(97 + i), // a,b,c...
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }

            const edgeSet = new Set();
            if (GRAPH_MODE === 'directed') {
                // Ensure reachability from a start vertex via chain + cycle
                for (let i = 0; i < numNodes - 1; i++) {
                    const k = `${newNodes[i].id}-${newNodes[i + 1].id}`;
                    if (!edgeSet.has(k)) { edgeSet.add(k); newEdges.push({ src: newNodes[i].id, dest: newNodes[i + 1].id }); }
                }
                if (numNodes > 1) {
                    const k = `${newNodes[numNodes - 1].id}-${newNodes[0].id}`;
                    if (!edgeSet.has(k)) { edgeSet.add(k); newEdges.push({ src: newNodes[numNodes - 1].id, dest: newNodes[0].id }); }
                }
                
                // Add VERY LIMITED random directed edges (0-2 max)
                const maxExtraEdges = Math.floor(Math.random() * 3);
                if(maxExtraEdges > 0) {
                    const allPairs = [];
                    for(let i=0; i<numNodes; i++) {
                        for(let j=0; j<numNodes; j++) {
                            if(i === j) continue;
                            const edgeKey = `${newNodes[i].id}-${newNodes[j].id}`;
                            if(!edgeSet.has(edgeKey)) {
                                allPairs.push({ src: newNodes[i].id, dest: newNodes[j].id, key: edgeKey });
                            }
                        }
                    }
                    // Shuffle
                    for(let i = allPairs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allPairs[i], allPairs[j]] = [allPairs[j], allPairs[i]];
                    }
                    // Add
                    for(let k = 0; k < Math.min(maxExtraEdges, allPairs.length); k++) {
                        const pair = allPairs[k];
                        edgeSet.add(pair.key);
                        newEdges.push({ src: pair.src, dest: pair.dest });
                    }
                }
            } else {
                // Undirected: Ensure connectivity (spanning tree chain)
                for (let i = 0; i < numNodes - 1; i++) {
                    const k = `${newNodes[i].id}-${newNodes[i + 1].id}`;
                    if (!edgeSet.has(k)) { edgeSet.add(k); newEdges.push({ src: newNodes[i].id, dest: newNodes[i + 1].id }); }
                }
                
                // Add VERY LIMITED random undirected edges (0-2 max)
                const maxExtraEdges = Math.floor(Math.random() * 3);
                if(maxExtraEdges > 0) {
                    const allPairs = [];
                    for(let i=0; i<numNodes; i++) {
                        for(let j=i+1; j<numNodes; j++) {
                            const edgeKey = `${newNodes[i].id}-${newNodes[j].id}`;
                            if(!edgeSet.has(edgeKey)) {
                                allPairs.push({ src: newNodes[i].id, dest: newNodes[j].id, key: edgeKey });
                            }
                        }
                    }
                    // Shuffle
                    for(let i = allPairs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allPairs[i], allPairs[j]] = [allPairs[j], allPairs[i]];
                    }
                    // Add
                    for(let k = 0; k < Math.min(maxExtraEdges, allPairs.length); k++) {
                        const pair = allPairs[k];
                        edgeSet.add(pair.key);
                        newEdges.push({ src: pair.src, dest: pair.dest });
                    }
                }
            }

            NODES = newNodes;
            EDGES = newEdges;

            // Keep START if still valid, else choose first node
            const ids = NODES.map(n => n.id);
            if (!ids.includes(START)) START = ids[0];
            syncStartDropdown();

            const steps = generateSteps();
            player.setSteps(steps);
            player.reset();
        }

        // Spanning Tree Generator (Randomized Tree Structure)
        function generateSpanningTree() {
            const numNodes = Math.floor(Math.random() * 3) + 6; // 6 to 8 nodes
            const newNodes = [];
            const newEdges = [];
            const width = 600;
            const height = 350;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;

            // Generate Nodes (Circular layout)
            for(let i=0; i<numNodes; i++) {
                const angle = (2 * Math.PI * i) / numNodes;
                newNodes.push({
                    id: String.fromCharCode(97 + i),
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }

            // Create a random tree structure (Randomized Prim's-like approach)
            const connected = [ newNodes[0] ];
            const unconnected = newNodes.slice(1);
            
            // While there are unconnected nodes
            while(unconnected.length > 0) {
                // Pick a random node from connected set
                const uIndex = Math.floor(Math.random() * connected.length);
                const u = connected[uIndex];
                
                // Pick a random node from unconnected set
                const vIndex = Math.floor(Math.random() * unconnected.length);
                const v = unconnected[vIndex];
                
                // Add edge
                newEdges.push({ src: u.id, dest: v.id });
                
                // Move v from unconnected to connected
                connected.push(v);
                unconnected.splice(vIndex, 1);
            }

            NODES = newNodes;
            EDGES = newEdges;

            // Sync start dropdown
            const ids = NODES.map(n => n.id);
            if (!ids.includes(START)) START = ids[0];
            syncStartDropdown();

            // Reset Player
            const steps = generateSteps();
            player.setSteps(steps);
            player.reset();
        }

        // Drag & Drop
        let isDragging = false;
        let draggedNodeId = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function handleMouseDown(e, nodeId) {
            if (e.button !== 0) return;
            isDragging = true;
            draggedNodeId = nodeId;
            e.stopPropagation();
            e.preventDefault();
            const rect = container.getBoundingClientRect();
            const node = NODES.find(n => n.id === nodeId);
            if(node) {
                dragOffsetX = (e.clientX - rect.left) - node.x;
                dragOffsetY = (e.clientY - rect.top) - node.y;
            }
            document.body.style.cursor = 'grabbing';
        }

        document.addEventListener('mousemove', (e) => {
            if (!isDragging || !draggedNodeId) return;
            const rect = container.getBoundingClientRect();
            const node = NODES.find(n => n.id === draggedNodeId);
            if (node) {
                let x = (e.clientX - rect.left) - dragOffsetX;
                let y = (e.clientY - rect.top) - dragOffsetY;
                node.x = Math.max(25, Math.min(rect.width - 25, x));
                node.y = Math.max(25, Math.min(rect.height - 25, y));
                player.updateUI();
            }
        });

        document.addEventListener('mouseup', () => {
            if(isDragging) {
                isDragging = false;
                draggedNodeId = null;
                document.body.style.cursor = 'default';
            }
        });

        let player;
        const container = document.getElementById('canvas-container');
        const queueDiv = document.getElementById('queue-visuals');
        const resultsEl = document.getElementById('results-table');
        const startSelect = document.getElementById('startSelect');

        function syncStartDropdown() {
            if (!startSelect) return;
            const ids = NODES.map(n => n.id);
            startSelect.innerHTML = '';
            ids.forEach(id => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = id;
                startSelect.appendChild(opt);
            });
            if (!ids.includes(START)) START = ids[0];
            startSelect.value = START;
        }

        function generateSteps() {
            let steps = [];
            let Q = [];
            let color = {};
            let d = {};
            let p = {};

            const adj = buildAdjacency(NODES, EDGES, GRAPH_MODE);
            
            NODES.forEach(n => {
                color[n.id] = 'WHITE';
                d[n.id] = Infinity;
                p[n.id] = null;
            });

            // Initialize (for each u != s): color=WHITE, d=‚àû, p=NIL
            steps.push({
                description: `Initialize: for each u ‚â† ${START}, set color[u]=WHITE, d[u]=‚àû, p[u]=NIL.`,
                codeLine: 2,
                state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: null, checking: null, start: START, mode: GRAPH_MODE }
            });

            // Set source values and enqueue
            color[START] = 'GRAY';
            d[START] = 0;
            p[START] = null;
            Q = [];

            steps.push({
                description: `Set source: color[${START}]=GRAY, d[${START}]=0, p[${START}]=NIL.`,
                codeLine: 6,
                state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: null, checking: null, start: START, mode: GRAPH_MODE }
            });

            steps.push({
                description: `Initialize queue: Q = ‚àÖ.`,
                codeLine: 9,
                state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: null, checking: null, start: START, mode: GRAPH_MODE }
            });

            Q.push(START);
            steps.push({
                description: `ENQUEUE(Q, ${START}).`,
                codeLine: 10,
                state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: null, checking: null, start: START, mode: GRAPH_MODE }
            });

            while(Q.length > 0) {
                steps.push({
                    description: `While Q ‚â† ‚àÖ (Q = [${Q.join(', ')}])`,
                    codeLine: 11,
                    state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: null, checking: null, start: START, mode: GRAPH_MODE }
                });

                const u = Q.shift(); // DEQUEUE
                
                steps.push({
                    description: `u = DEQUEUE(Q) ‚Üí <strong>${u}</strong>.`,
                    codeLine: 12,
                    state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: null, start: START, mode: GRAPH_MODE }
                });

                const neighbors = getNeighborsFromAdj(adj, u); // DO NOT SORT
                for(let v of neighbors) {
                    steps.push({
                        description: `For each v in Adj[${u}] (consider <strong>${v}</strong>).`,
                        codeLine: 13,
                        state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: v, start: START, mode: GRAPH_MODE }
                    });

                    steps.push({
                        description: `If color[${v}] == WHITE`,
                        codeLine: 14,
                        state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: v, start: START, mode: GRAPH_MODE }
                    });

                    if(color[v] === 'WHITE') {
                        color[v] = 'GRAY';
                        steps.push({
                            description: `color[${v}] = GRAY`,
                            codeLine: 15,
                            state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: v, start: START, mode: GRAPH_MODE }
                        });

                        d[v] = d[u] + 1;
                        steps.push({
                            description: `d[${v}] = d[${u}] + 1 ‚Üí ${d[v]}`,
                            codeLine: 16,
                            state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: v, start: START, mode: GRAPH_MODE }
                        });

                        p[v] = u;
                        steps.push({
                            description: `p[${v}] = ${u}`,
                            codeLine: 17,
                            state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: v, start: START, mode: GRAPH_MODE }
                        });

                        Q.push(v);
                        steps.push({
                            description: `ENQUEUE(Q, ${v}) ‚Üí Q = [${Q.join(', ')}]`,
                            codeLine: 18,
                            state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: v, start: START, mode: GRAPH_MODE }
                        });
                    }
                }

                color[u] = 'BLACK';
                steps.push({
                    description: `color[${u}] = BLACK`,
                    codeLine: 19,
                    state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: u, checking: null, start: START, mode: GRAPH_MODE }
                });
            }

            steps.push({
                description: "BFS Traversal Complete.",
                codeLine: null,
                state: { color: {...color}, d: {...d}, p: {...p}, Q: [...Q], current: null, checking: null, start: START, mode: GRAPH_MODE }
            });

            return steps;
        }

        function render(state) {
            // Queue
            queueDiv.innerHTML = '';
            state.Q.forEach(item => {
                const el = document.createElement('div');
                el.className = 'queue-item';
                el.innerText = item;
                queueDiv.appendChild(el);
            });

            // Graph
            const oldSvg = container.querySelector('svg');
            if(oldSvg) oldSvg.remove();
            const svg = createSVGElement('svg', { width: '100%', height: '100%', style: 'position:absolute; top:0; left:0; z-index:0;' });

            // Results table (live)
            if (resultsEl) {
                const rows = NODES.map(n => n.id).sort();
                let html = '<table style="width:100%; border-collapse:collapse; color: var(--text-main);">';
                html += '<thead><tr style="background: rgba(0, 0, 0, 0.3); border-bottom: 1px solid var(--border-color);">';
                html += '<th style="text-align:left; padding:6px 8px; font-weight:600; color: var(--text-mute);">u</th>';
                html += '<th style="padding:6px 8px; font-weight:600; color: var(--text-mute);">color</th>';
                html += '<th style="padding:6px 8px; font-weight:600; color: var(--text-mute);">d</th>';
                html += '<th style="padding:6px 8px; font-weight:600; color: var(--text-mute);">p</th>';
                html += '</tr></thead><tbody>';
                rows.forEach(id => {
                    const col = state.color[id] || 'WHITE';
                    const dVal = state.d[id];
                    const pVal = state.p ? (state.p[id] === null ? 'NIL' : state.p[id]) : 'NIL';
                    const isCurrent = state.current === id;
                    const rowStyle = isCurrent ? 'background: rgba(255, 234, 0, 0.15);' : '';
                    html += `<tr style="${rowStyle} border-bottom: 1px solid rgba(255,255,255,0.05);">`;
                    html += `<td style="padding:6px 8px; text-align:left; font-weight:700; color: var(--accent);">${id}</td>`;
                    html += `<td style="padding:6px 8px;">${col}</td>`;
                    html += `<td style="padding:6px 8px; color:#00bcd4; font-weight:${dVal !== Infinity ? 'bold' : 'normal'};">${dVal === Infinity ? '‚àû' : dVal}</td>`;
                    html += `<td style="padding:6px 8px; color:${pVal === 'NIL' ? 'var(--text-mute)' : 'var(--text-main)'};">${pVal}</td>`;
                    html += `</tr>`;
                });
                html += '</tbody></table>';
                resultsEl.innerHTML = html;
            }

            // Arrow marker for directed edges
            const defs = createSVGElement('defs', {});
            const marker = createSVGElement('marker', { id: 'arrow', markerWidth: 10, markerHeight: 10, refX: 9, refY: 3, orient: 'auto' });
            const mPath = createSVGElement('path', { d: 'M0,0 L0,6 L9,3 z', fill: '#666' });
            marker.appendChild(mPath);
            defs.appendChild(marker);
            svg.appendChild(defs);

            // Edges (directed/undirected) + BFS tree edges
            EDGES.forEach(e => {
                const u = NODES.find(n => n.id === e.src);
                const v = NODES.find(n => n.id === e.dest);
                // Handle potential stale edges from random gen
                if(!u || !v) return;

                const dx = v.x - u.x;
                const dy = v.y - u.y;
                const distLen = Math.hypot(dx, dy);
                const offset = 25;
                const startX = u.x + (dx / distLen) * offset;
                const startY = u.y + (dy / distLen) * offset;
                const endX = v.x - (dx / distLen) * offset;
                const endY = v.y - (dy / distLen) * offset;

                const line = createSVGElement('line', {
                    x1: startX, y1: startY, x2: endX, y2: endY,
                    stroke: '#666', 'stroke-width': 2, 'stroke-opacity': 0.3
                });

                const isCheckingDirected = (state.current === e.src && state.checking === e.dest);
                const isCheckingUndirected = (state.current === e.src && state.checking === e.dest) || (state.current === e.dest && state.checking === e.src);
                const isChecking = (GRAPH_MODE === 'directed') ? isCheckingDirected : isCheckingUndirected;

                const isTreeDirected = state.p && state.p[e.dest] === e.src;
                const isTreeUndirected = state.p && ((state.p[e.dest] === e.src) || (state.p[e.src] === e.dest));
                const isTree = (GRAPH_MODE === 'directed') ? isTreeDirected : isTreeUndirected;

                if (isTree) {
                    line.setAttribute('stroke', '#00e676');
                    line.setAttribute('stroke-width', 4);
                    line.setAttribute('stroke-opacity', 1);
                } else if (isChecking) {
                    line.setAttribute('stroke', '#ffea00');
                    line.setAttribute('stroke-width', 3);
                    line.setAttribute('stroke-opacity', 1);
                }

                if (GRAPH_MODE === 'directed') {
                    line.setAttribute('marker-end', 'url(#arrow)');
                }

                svg.appendChild(line);
            });

            // Nodes
            NODES.forEach(n => {
                const g = createSVGElement('g', { 
                    transform: `translate(${n.x}, ${n.y})`,
                    style: 'cursor: grab'
                });
                g.addEventListener('mousedown', (e) => handleMouseDown(e, n.id));
                
                let fill = '#fff';
                let stroke = '#444';
                
                if(state.color[n.id] === 'WHITE') { fill = '#333'; stroke = '#666'; }
                if(state.color[n.id] === 'GRAY') { fill = '#2196f3'; stroke = '#2196f3'; }
                if(state.color[n.id] === 'BLACK') { fill = '#00e676'; stroke = '#00e676'; }

                const circle = createSVGElement('circle', {
                    r: 25, fill: fill, stroke: stroke, 'stroke-width': 2
                });

                if(state.current === n.id) {
                    circle.setAttribute('stroke', '#ffea00');
                    circle.setAttribute('stroke-width', 4);
                }

                const label = createSVGElement('text', {
                    dy: 5, 'text-anchor': 'middle', 
                    fill: '#fff',
                    'font-weight': 'bold',
                    style: 'pointer-events: none; user-select: none;'
                });
                label.textContent = n.id;

                // Dist Label
                const distVal = state.d[n.id];
                const distText = distVal === Infinity ? '‚àû' : distVal;
                const bgRect = createSVGElement('rect', {
                    x: -18, y: -45,
                    width: 36, height: 18,
                    rx: 3,
                    fill: 'rgba(0, 0, 0, 0.85)',
                    stroke: '#00bcd4',
                    'stroke-width': '1.5'
                });
                const dLabel = createSVGElement('text', {
                    dy: -32, 'text-anchor': 'middle', fill: '#00bcd4', 'font-size': '11px', 'font-weight': 'bold',
                    style: 'pointer-events: none; user-select: none;'
                });
                dLabel.textContent = distText;
                g.appendChild(bgRect);
                g.appendChild(dLabel);

                g.appendChild(circle);
                g.appendChild(label);
                svg.appendChild(g);
            });

            container.appendChild(svg);
        }

        function loadSlideExample() {
            GRAPH_MODE = SLIDE_EXAMPLE.mode;
            START = SLIDE_EXAMPLE.start;
            NODES = JSON.parse(JSON.stringify(SLIDE_EXAMPLE.nodes));
            EDGES = JSON.parse(JSON.stringify(SLIDE_EXAMPLE.edges));
            document.getElementById('modeUndirected').checked = true;
            document.getElementById('modeDirected').checked = false;
            syncStartDropdown();
            const steps = generateSteps();
            player.setSteps(steps);
            player.reset();
        }

        const steps = generateSteps();
        player = new StepPlayer(render, null);
        syncStartDropdown();
        player.setSteps(steps);
        
        document.getElementById('btnRandom').addEventListener('click', generateRandomGraph);
        document.getElementById('btnSpanTree').addEventListener('click', generateSpanningTree);
        document.getElementById('btnExample').addEventListener('click', loadSlideExample);

        // Start selection
        startSelect.addEventListener('change', (e) => {
            START = e.target.value;
            const steps = generateSteps();
            player.setSteps(steps);
            player.reset();
        });

        // Graph mode toggles
        document.getElementById('modeDirected').addEventListener('change', () => {
            GRAPH_MODE = 'directed';
            const steps = generateSteps();
            player.setSteps(steps);
            player.reset();
        });
        document.getElementById('modeUndirected').addEventListener('change', () => {
            GRAPH_MODE = 'undirected';
            const steps = generateSteps();
            player.setSteps(steps);
            player.reset();
        });
    </script>
</body>
</html>
